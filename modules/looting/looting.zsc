class UaS_SearchedCorpseMarker : Inventory {
	array<string> Loot;
	int searchedAmount;
	bool foundSomething;
	string lastMessage;
	bool fullysearched;

	// TODO replace this with actual tables
	void InitLoot() {
		Loot.Push("HD4mMag");
		Loot.Push("");
		Loot.Push("HD9mMag15");
		Loot.Push("");
		Loot.Push("PortableStimpack");
	}

	void ReturnLoot() {
		int check = (
			random[loot](0,100) +
			random[loot](0,100) +
			random[loot](0,100)) / 3;

		if (check < searchedAmount) {
			// On successful search check, see if there's actually loot in this pocket
			if(Loot[0] == "") {
				// Spawn some debris for an empty pocket
				if(UaS_Debug & Looting) { console.printf("Empty pocket..."); }
				SpawnLootDebris();
				SearchedAmount = 0;
				Loot.Delete(0);
			}
			else {
				// Actually spawn the loot and reset
				if(UaS_Debug & Looting) { console.printf("Loot spawn: "..Loot[0]); }
				UaS.SpawnStuff(Loot[0], 1, owner.pos, true);
				Loot.Delete(0);
				SearchedAmount = 0;
				foundSomething = true;
			}
		}
		else {
			// Otherwise just increment progress
			searchedAmount += random[loot](5,25);
			if(UaS_Debug & Looting) { console.printf("Check "..check.." -- Progress "..searchedAmount); }
		}
		// Mark complete if no more loot entries
		if (Loot.Size() <= 0) { fullysearched = true; }
	}

	void SpawnLootDebris() {
		for (int i = 0; i < 5; i++) {
			owner.A_SpawnItemEx("TinyWallChunk",
				zofs: 4,
				xvel: frandom[loot](4, 7),
				yvel: frandom[loot](-2, 2),
				zvel: frandom[loot](-2, 1),
				flags: SXF_NOCHECKPOSITION,
				failchance: 64);
		}
	}
}

class UaS_Looting_Handler : Inventory {
	int cooldown;
	double anglevel, pitchvel;

	default {
		+INVENTORY.PERSISTENTPOWER;
		+INVENTORY.UNDROPPABLE;
		-INVENTORY.INVBAR;
		+INVENTORY.UNTOSSABLE;
	}

	override void BeginPlay() {
		super.BeginPlay();
		//InitializeLootTables();
		InitializeStrings();
	}

	override void DoEffect() {
		super.DoEffect();
		if (!owner) { return; }
		if (owner.health <= 0) { return; }
		if (!owner.player.ReadyWeapon) { return; }
		if (!(owner.player.ReadyWeapon is "HDFist")) { return; }

		if (TryingToSearch()) {
			FLineTraceData trace;
			owner.LineTrace(owner.angle, 32, owner.pitch, offsetz: (owner.height / 2), data: trace);
			if (trace.HitActor && trace.HitActor.bCorpse) {
				DoSearch(trace.HitActor);
				cooldown = max(cooldown - 1, 0);
			}
		}

		HDPlayerPawn(owner).wephelptext = HDWeapon(owner.player.ReadyWeapon).gethelptext()..
			WEPHELP_USE.."   Crouch next to a body\n      and hold to search.";

		// Nudge owner angle/pitch
		owner.angle += anglevel;
		owner.pitch += pitchvel;
		anglevel *= 0.75;
		pitchvel *= 0.75;
	}

	bool TryingToSearch() {
		return (
			(owner.player.cmd.buttons & BT_USE) &&
			owner.player.CrouchFactor <= 0.5);
	}

	void DoSearch(actor searchTarget) {
		UaS_SearchedCorpseMarker searchMarker;
		if (!searchTarget) { return; }
		if (searchTarget.countinv("UaS_SearchedCorpseMarker") == 0) {
			searchTarget.GiveInventory("UaS_SearchedCorpseMarker", 1);
			searchMarker = UaS_SearchedCorpseMarker(searchTarget.FindInventory("UaS_SearchedCorpseMarker"));
			searchMarker.InitLoot();
		}
		searchMarker = UaS_SearchedCorpseMarker(searchTarget.FindInventory("UaS_SearchedCorpseMarker"));
		if (!searchMarker) { return; }

		//Actually do the search
		if (cooldown == 0) {
			if (searchMarker.fullysearched) {
				HDWeapon currentWeapon = HDWeapon(owner.player.ReadyWeapon);
				if(searchMarker.lastMessage == "") { searchMarker.lastMessage = FlavorText(searchMarker.foundSomething); }
				currentWeapon.A_WeaponMessage(searchMarker.lastMessage);
				return;
			}
			owner.A_StartSound("weapons/pocket", volume: frandom(0.5, 0.75));
			anglevel += frandom[loot](-1, 1);
			pitchvel += frandom[loot](-1, 1);
			cooldown = random[loot](10,25);
			searchMarker.ReturnLoot();
		}
	}
}

// TODO Actually re-implement all this crap somehow

	// bool SpawnLoot(actor spawnTarget) {
		// int tableSize = 0;
		// int lootIndex = 0;
		// string LootClass = "";
		// int minAmount = 0;
		// int maxAmount = 0;
		// double rarityFactor = 0;
//
		// if(spawnTarget is "ZombieStormtrooper") {
			// int weapontype = ZombieStormtrooper(spawnTarget).firemode;
			// switch(weapontype) {
				// case -2:
					// tableSize = ZombieStormtrooperSMGLoot.Size() - 1;
					// lootIndex = random(0, tableSize);
					// LootClass = ZombieStormtrooperSMGLoot[lootIndex].itemName;
					// minAmount = ZombieStormtrooperSMGLoot[lootIndex].minAmount;
					// maxAmount = ZombieStormtrooperSMGLoot[lootIndex].maxAmount;
					// rarityFactor = ZombieStormtrooperSMGLoot[lootIndex].rarityFactor;
					// break;
				// default:
					// tableSize = ZombieStormtrooperZM66Loot.Size() - 1;
					// lootIndex = random(0, tableSize);
					// LootClass = ZombieStormtrooperZM66Loot[lootIndex].itemName;
					// minAmount = ZombieStormtrooperZM66Loot[lootIndex].minAmount;
					// maxAmount = ZombieStormtrooperZM66Loot[lootIndex].maxAmount;
					// rarityFactor = ZombieStormtrooperZM66Loot[lootIndex].rarityFactor;
					// break;
			// }
		// }
		// if(spawnTarget is "HideousShotgunGuy") {
			// int weapontype = HideousShotgunGuy(spawnTarget).wep;
			// switch(weapontype) {
				// case -1:
					// tableSize = ZombieStormtrooperZM66Loot.Size() - 1;
					// lootIndex = random(0, tableSize);
					// LootClass = ZombieStormtrooperZM66Loot[lootIndex].itemName;
					// minAmount = ZombieStormtrooperZM66Loot[lootIndex].minAmount;
					// maxAmount = ZombieStormtrooperZM66Loot[lootIndex].maxAmount;
					// rarityFactor = ZombieStormtrooperZM66Loot[lootIndex].rarityFactor;
					// break;
				// default:
					// tableSize = HideousShotgunGuyLoot.Size() - 1;
					// lootIndex = random(0, tableSize);
					// LootClass = HideousShotgunGuyLoot[lootIndex].itemName;
					// minAmount = HideousShotgunGuyLoot[lootIndex].minAmount;
					// maxAmount = HideousShotgunGuyLoot[lootIndex].maxAmount;
					// rarityFactor = HideousShotgunGuyLoot[lootIndex].rarityFactor;
					// break;
			// }
		// }
		// if(spawnTarget is "VulcanetteGuy") {
			// tableSize = DragonGuardLoot.Size() - 1;
			// lootIndex = random(0, tableSize);
			// LootClass = DragonGuardLoot[lootIndex].itemName;
			// minAmount = DragonGuardLoot[lootIndex].minAmount;
			// maxAmount = DragonGuardLoot[lootIndex].maxAmount;
			// rarityFactor = DragonGuardLoot[lootIndex].rarityFactor;
		// }
		// if(spawnTarget is "HDMarine") {
			// int weapontype = HDMarine(spawnTarget).wep;
			// switch(weapontype) {
				// case 1:
					// tableSize = HDMarineZM66Loot.Size() - 1;
					// lootIndex = random(0, tableSize);
					// LootClass = HDMarineZM66Loot[lootIndex].itemName;
					// minAmount = HDMarineZM66Loot[lootIndex].minAmount;
					// maxAmount = HDMarineZM66Loot[lootIndex].maxAmount;
					// rarityFactor = HDMarineZM66Loot[lootIndex].rarityFactor;
					// break;
				// case 2:
					// tableSize = HDMarineHunterLoot.Size() - 1;
					// lootIndex = random(0, tableSize);
					// LootClass = HDMarineHunterLoot[lootIndex].itemName;
					// minAmount = HDMarineHunterLoot[lootIndex].minAmount;
					// maxAmount = HDMarineHunterLoot[lootIndex].maxAmount;
					// rarityFactor = HDMarineHunterLoot[lootIndex].rarityFactor;
					// break;
				// case 3:
					// tableSize = HDMarineSMGLoot.Size() - 1;
					// lootIndex = random(0, tableSize);
					// LootClass = HDMarineSMGLoot[lootIndex].itemName;
					// minAmount = HDMarineSMGLoot[lootIndex].minAmount;
					// maxAmount = HDMarineSMGLoot[lootIndex].maxAmount;
					// rarityFactor = HDMarineSMGLoot[lootIndex].rarityFactor;
					// break;
				// case 4:
					// tableSize = HDMarineRocketLoot.Size() - 1;
					// lootIndex = random(0, tableSize);
					// LootClass = HDMarineRocketLoot[lootIndex].itemName;
					// minAmount = HDMarineRocketLoot[lootIndex].minAmount;
					// maxAmount = HDMarineRocketLoot[lootIndex].maxAmount;
					// rarityFactor = HDMarineRocketLoot[lootIndex].rarityFactor;
					// break;
			// }
		// }
	// }

// class UaS_LootEntry {
	// name itemName;
	// int minAmount, maxAmount;
	// double rarityFactor;
//
	// static UaS_LootEntry create(name newName, int newMin, int newMax, double rarity) {
		// UaS_LootEntry newEntry = new("UaS_LootEntry");
		// newEntry.itemName = newName;
		// newEntry.minAmount = newMin;
		// newEntry.maxAmount = newMax;
		// newEntry.rarityFactor = rarity;
		// return newEntry;
	// }
// }
